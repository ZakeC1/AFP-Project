\begin{code}
module GameTheoryDraft where
open import MLTT.Spartan
open import Fin.Type
open import MLTT.Athenian
            hiding (Fin ; ğŸ ; ğŸ ; ğŸ ; ğŸ‘ ; ğŸ’ ; ğŸ“ ; ğŸ” ; ğŸ• ; ğŸ– ; ğŸ—)
\end{code}

Creating the tree data type and defining an empty tree as [] and generating larger trees by using the _âˆ·_.
\begin{code}
data Tree : Setâ‚ where
  []  : Tree
  _âˆ·_ : (X : Type) (Xf : X â†’ Tree) â†’ Tree

\end{code}

Paths of the tree defined inductively. The empty tree doesn't have any vertices so is just the unit type ğŸ™ whereas any other path in a tree is generated by a vertex on a level where there is a shorter path linking that vertex to the root. This is then repeated inductively until the root and empty tree is reached. So x would be the head of the path (a vertex at the bottom of the tree) and the Path (Xf x) is the tail of this path.

\begin{code}

pattern âŸ¨âŸ©       = â‹† 
pattern _::_ x xs = (x , xs)

Path : Tree â†’ Type
Path []       = ğŸ™
Path (X âˆ· Xf) = Î£ x ê‰ X , Path (Xf x)

path-head : {X : Type} {Xf : X â†’ Tree} â†’ Path (X âˆ· Xf) â†’ X
path-head (x :: xs) = x

path-tail : {X : Type} {Xf : X â†’ Tree} ((x :: xs) : Path (X âˆ· Xf)) â†’ Path (Xf x)
path-tail (x :: xs) = xs

path-length : {Xt : Tree} â†’ Path Xt â†’ â„•
path-length {[]}     âŸ¨âŸ©        = 0
path-length {X âˆ· Xf} (x :: xs) = succ (path-length {Xf x} xs)

\end{code}

We now go through the example with Connect 4 and define the type of outcomes as:

\begin{code}
Outcome : Type
Outcome = Fin 3
\end{code}

As well as defining the players and the meaning of each outcome.

\begin{code}
data Player : Type where
  Red Blue : Player

oppenent : Player â†’ Player
oppenent Red = Blue
oppenent Blue = Red

P1-wins draw P2-wins : Outcome
P1-wins = ğŸ
draw = ğŸ
P2-wins = ğŸ
\end{code}

The board is required so that the players can play their game. This is defined by a type of boards where for a board (p , A) where p is the player who plays next and the board A is the current state of the game's board.

\begin{code}
Grid = Fin 7 Ã— Fin 7
Matrix = Grid â†’ Maybe Player
Board = Player Ã— Matrix

\end{code}
Where the initial board is defined with an empty grid and Red to play first shown by:

\begin{code}
start-board : Board
start-board = Red , Î» _ â†’ Nothing
\end{code}

All the wins can be defined by matching on all possible combinations of 4 in a row. This is done by providing a player so Red or Blue and the current state of the game. Then by matrching the current player to each spot of the grid and comparing them to relevant spaces if they also contain the same player's pieces which would result in a connect 4. If this does then true will be returned, otehrwise there is not a connect 4 so false is given.

\begin{code}

_is_ : Maybe Player â†’ Player â†’ Bool
Nothing is _ = false
Just Red  is Red = true
Just Blue  is Red = false
Just Red  is Blue = false
Just Blue  is Blue = true
    
wins : Player â†’ Matrix â†’ Bool
wins p M = line || col || diag
  where

    line1 = {!!}
    line2 = {!!}

    col1 = {!!}
    col2 = {!!}

    diag1 = {!!}
    diag2 = {!!}

    line = line1 || line2
    col = col1 || col2
    diag = diag1 || diag2
\end{code}
Find first empy square in a column.
\begin{code}

isNoth_ : Maybe Player â†’ Bool
isNoth Nothing = true
isNoth _ = false

Fina : Fin 7 â†’ Bool
Fina (inl (inl (inl x))) = {!!}
Fina (inl (inl (inr x))) = {!!}
Fina (inl (inr x)) = {!!}
Fina (inr x) = {!!}

EmptySquare : {n : â„•} â†’ Board â†’ Maybe (Fin n)
EmptySquare (p , m) = {!!} --goal
  where
    goal : {n : â„•} (x : Fin n) â†’ Maybe (Fin n)
    goal x with (isNoth (m (ğŸ , {!!})))
    ... | true = Just {!x!}
    ... | false = if {!x == 7!} then Nothing else {!goal (fsucc x)!}
    --(x == ((((((ğŸ˜ + ğŸ™) + ğŸ™) + ğŸ™) + ğŸ™) + ğŸ™) + ğŸ™) + ğŸ™)

data EmptySet : Set where


EmptySquare1 : Board â†’ Fin 7 â†’ Set
EmptySquare1 (p , m) col =      if (isNoth (m (ğŸ , col))) then (m (ğŸ , col) ï¼ Nothing)
                           else if (isNoth (m (ğŸ , col))) then (m (ğŸ , col) ï¼ Nothing)
                           else if (isNoth (m (ğŸ , col))) then (m (ğŸ , col) ï¼ Nothing)
                           else if (isNoth (m (ğŸ‘ , col))) then (m (ğŸ‘ , col) ï¼ Nothing)
                           else if (isNoth (m (ğŸ’ , col))) then (m (ğŸ’ , col) ï¼ Nothing)
                           else if (isNoth (m (ğŸ“ , col))) then (m (ğŸ“ , col) ï¼ Nothing)
                           else if (isNoth (m (ğŸ” , col))) then (m (ğŸ” , col) ï¼ Nothing)
                           else EmptySet
                           

Move : Board â†’ Set (ğ“¤â‚€ âŠ” ğ“¤â‚€)
Move (p , m) = Î£ x ê‰ Fin 7 , EmptySquare1 (p , m) x -- Î£ (x , y) ê‰ Grid , m (ğŸ , y) ï¼ Nothing

    --Grid1 : Set
    --Grid1 = Î£ (x , y) ê‰ Grid , b (x , y) ï¼ Nothing


\end{code}

