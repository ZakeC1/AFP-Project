\begin{code}
module GameTheoryFinal where
open import MLTT.Spartan
open import Fin.Type
open import MLTT.Athenian
            hiding (Fin ; ğŸ ; ğŸ ; ğŸ ; ğŸ‘ ; ğŸ’ ; ğŸ“ ; ğŸ” ; ğŸ• ; ğŸ– ; ğŸ—)
open import TypeTopology.DiscreteAndSeparated
open import TypeTopology.SigmaDiscreteAndTotallySeparated
open import TypeTopology.CompactTypes
open import Fin.Topology
\end{code}

Creating the tree data type and defining an empty tree as []. Larger trees are generated by using the _âˆ·_.

\begin{code}
data Tree : Setâ‚ where
  []  : Tree
  _âˆ·_ : (X : Type) (Xf : X â†’ Tree) â†’ Tree
\end{code}

Paths of the tree defined inductively. The empty tree doesn't have any vertices so it's just the unit type ğŸ™ whereas any other path in a tree is generated by a vertex on a level where there is a shorter path linking that vertex to the root. This is then repeated inductively until the root/empty tree is reached. So x would be the head of the path (a vertex at the bottom of the tree) and the Path (Xf x) is the tail of this path.

\begin{code}
pattern âŸ¨âŸ©       = â‹† 
pattern _::_ x xs = (x , xs)

Path : Tree â†’ Type
Path []       = ğŸ™
Path (X âˆ· Xf) = Î£ x ê‰ X , Path (Xf x)

path-head : {X : Type} {Xf : X â†’ Tree} â†’ Path (X âˆ· Xf) â†’ X
path-head (x :: xs) = x

path-tail : {X : Type} {Xf : X â†’ Tree} ((x :: xs) : Path (X âˆ· Xf)) â†’ Path (Xf x)
path-tail (x :: xs) = xs

path-length : {Xt : Tree} â†’ Path Xt â†’ â„•
path-length {[]}     âŸ¨âŸ©        = 0
path-length {X âˆ· Xf} (x :: xs) = succ (path-length {Xf x} xs)
\end{code}

We now go through the example with Connect 4 and define the type of outcomes as:

\begin{code}
Outcome : Type
Outcome = Fin 3
\end{code}

As well as defining the players and the meaning of each outcome.

\begin{code}
data Player : Type where
  Red Blue : Player

oppenent : Player â†’ Player
oppenent Red = Blue
oppenent Blue = Red

Red-wins Draw Blue-wins : Outcome
Red-wins = ğŸ
Draw = ğŸ
Blue-wins = ğŸ
\end{code}

The board is required so that the players can play their game. This is defined by a type of board (p , A) where p is the player who plays next and the board A is the current state of the game's board. The grid represents the Connect 4 Grid which is a 6x7.

\begin{code}
Grid = Fin 6 Ã— Fin 7
Matrix = Grid â†’ Maybe Player
Board = Player Ã— Matrix
\end{code}

Where the initial board is defined with an empty grid and Red to play first shown by:

\begin{code}
start : Board
start = Red , Î» _ â†’ Nothing
\end{code}

Checks if a player has won by comparing all possible Connect 4s and the current players positions. This is done by providing a player (Red or Blue) and the current state of the game. Then by matching the current player to each spot of the grid and the relevant spaces related to each spot to see if they have a Connect 4. If the player has a Connect 4 then true will be returned, otherwise there is not a connect 4 so false is given.

\begin{code}
--Matching the maybes to the corresponding players so booleans can represent them instead when finding all possible Connect 4s.
_is_ : Maybe Player â†’ Player â†’ Bool
Nothing is _ = false
Just Red  is Red = true
Just Blue  is Red = false
Just Red  is Blue = false
Just Blue  is Blue = true

-- Ensures that is takes precedence so less brackets can be used.
infix 100 _is_

-- Checks if a player given has won yet.
wins : Player â†’ Matrix â†’ Bool
wins p M = lines || cols || diags
  where

    -- Finds all row connect 4s in a given row of the board
    lineRow : Fin 6 â†’ Bool
    lineRow x = M (x , ğŸ) is p && M (x , ğŸ) is p && M (x , ğŸ) is p && M (x , ğŸ‘) is p ||
              M (x , ğŸ) is p && M (x , ğŸ) is p && M (x , ğŸ‘) is p && M (x , ğŸ’) is p ||
              M (x , ğŸ) is p && M (x , ğŸ‘) is p && M (x , ğŸ’) is p && M (x , ğŸ“) is p ||
              M (x , ğŸ‘) is p && M (x , ğŸ’) is p && M (x , ğŸ“) is p && M (x , ğŸ”) is p
    -- All row connect 4s in the entire board
    lines = lineRow ğŸ || lineRow ğŸ || lineRow ğŸ || lineRow ğŸ‘ || lineRow ğŸ’ || lineRow ğŸ“

    -- Finds all column connect 4s in a specified column
    lineCol : Fin 7 â†’ Bool
    lineCol x = M (ğŸ , x) is p && M (ğŸ , x) is p && M (ğŸ , x) is p && M (ğŸ‘ , x) is p ||
                M (ğŸ , x) is p && M (ğŸ , x) is p && M (ğŸ‘ , x) is p && M (ğŸ’ , x) is p ||
                M (ğŸ , x) is p && M (ğŸ‘ , x) is p && M (ğŸ’ , x) is p && M (ğŸ“ , x) is p
    -- Finds all column connect 4s in the entire board
    cols = lineCol ğŸ || lineCol ğŸ || lineCol ğŸ || lineCol ğŸ‘ || lineCol ğŸ’ || lineCol ğŸ“ || lineCol ğŸ”

    -- Fin successor so diagonal can be defined easier
    FinSucc6 : Fin 6 â†’ Fin 6
    FinSucc6 ğŸ = ğŸ
    FinSucc6 ğŸ = ğŸ
    FinSucc6 ğŸ = ğŸ‘
    FinSucc6 ğŸ‘ = ğŸ’
    FinSucc6 ğŸ’ = ğŸ“
    -- Successor of ğŸ“ won't be used as connect 4 doesn't wrap around the board so irrelevant here
    FinSucc6 ğŸ“ = ğŸ
    -- Finds all diagonals based on row position going diagonally downwards left to right and also right to left
    lineDiag : Fin 6 â†’ Bool
    lineDiag x = M (x , ğŸ) is p && M (FinSucc6 x , ğŸ) is p && M (FinSucc6 (FinSucc6 x) , ğŸ) is p && M (FinSucc6 (FinSucc6 (FinSucc6 x)) , ğŸ‘) is p ||
                 M (x , ğŸ) is p && M (FinSucc6 x , ğŸ) is p && M (FinSucc6 (FinSucc6 x) , ğŸ‘) is p && M (FinSucc6 (FinSucc6 (FinSucc6 x)) , ğŸ’) is p ||
                 M (x , ğŸ) is p && M (FinSucc6 x , ğŸ‘) is p && M (FinSucc6 (FinSucc6 x) , ğŸ’) is p && M (FinSucc6 (FinSucc6 (FinSucc6 x)) , ğŸ“) is p ||
                 M (x , ğŸ‘) is p && M (FinSucc6 x , ğŸ’) is p && M (FinSucc6 (FinSucc6 x) , ğŸ“) is p && M (FinSucc6 (FinSucc6 (FinSucc6 x)) , ğŸ”) is p ||
                 -- Finds the opposite diagonal (right to left diagonal)
                 M (x , ğŸ”) is p && M (FinSucc6 x , ğŸ“) is p && M (FinSucc6 (FinSucc6 x) , ğŸ’) is p && M (FinSucc6 (FinSucc6 (FinSucc6 x)) , ğŸ‘) is p ||
                 M (x , ğŸ“) is p && M (FinSucc6 x , ğŸ’) is p && M (FinSucc6 (FinSucc6 x) , ğŸ‘) is p && M (FinSucc6 (FinSucc6 (FinSucc6 x)) , ğŸ) is p ||
                 M (x , ğŸ’) is p && M (FinSucc6 x , ğŸ‘) is p && M (FinSucc6 (FinSucc6 x) , ğŸ) is p && M (FinSucc6 (FinSucc6 (FinSucc6 x)) , ğŸ) is p ||
                 M (x , ğŸ‘) is p && M (FinSucc6 x , ğŸ) is p && M (FinSucc6 (FinSucc6 x) , ğŸ) is p && M (FinSucc6 (FinSucc6 (FinSucc6 x)) , ğŸ) is p 
    -- Finds all diagonal connect 4s of the entire board
    diags = lineDiag ğŸ || lineDiag ğŸ || lineDiag ğŸ
\end{code}

We make a function to denote that an empty slot is playable by a simple match of booleans on Nothing or the players.

\begin{code}
isNoth_ : Maybe Player â†’ Bool
isNoth Nothing = true
isNoth Just p = false
\end{code}

Defined the empty set and we have EmptySquare to find the first empty slot in a given column as the moves viable to a player is based on this. If the column is full then no empty square so the empty set is returned. Using if to ensure that no further space is found after the first one is.

\begin{code}
data EmptySet : Set where

EmptySquareCol : Board â†’ Fin 7 â†’ Set
EmptySquareCol (p , m) col = if (isNoth (m (ğŸ , col))) then (m (ğŸ , col) ï¼ Nothing)
                           else if (isNoth (m (ğŸ , col))) then (m (ğŸ , col) ï¼ Nothing)
                           else if (isNoth (m (ğŸ , col))) then (m (ğŸ , col) ï¼ Nothing)
                           else if (isNoth (m (ğŸ‘ , col))) then (m (ğŸ‘ , col) ï¼ Nothing)
                           else if (isNoth (m (ğŸ’ , col))) then (m (ğŸ’ , col) ï¼ Nothing)
                           else if (isNoth (m (ğŸ“ , col))) then (m (ğŸ“ , col) ï¼ Nothing)
                           else EmptySet                           
\end{code}

Finding all viable moves for the current player and board by creating a set of all empty sqaures. The viable empty squares are found by using the previous function so only the bottom of each empty column is part of the set of playable moves. Done by passing each column into the EmptySquare function as shown. So a maximum of 7 total moves could be found if none of the columns are full.

\begin{code}
Move : Board â†’ Set (ğ“¤â‚€ âŠ” ğ“¤â‚€)
Move (p , m) = Î£ col ê‰ Fin 7 , EmptySquareCol (p , m) col 
\end{code}

Therefore, we have defined the outline of the initial games and provided the definitions requires to generate a tree of all possible moves. Each player can find their viable moves and the board can be checked if there is currently a win. Future steps would be the generate the tree and to have the players play their best moves based upon the tree. However the tree for Connect 4 is extremely large due to the possibilities the piece's positions so program in Agda may be slow when processing the information.

In conclusion, an overview of the code for the Connect 4 game is shown.
